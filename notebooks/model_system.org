#+title: Model System
#+startup: latexpreview inlineimages
#+latex_header: \usepackage{braket}
#+property: header-args:julia :session jl :results silent

* Setup
** Imports
#+begin_src julia
using DrWatson
quickactivate("$(pwd())../")
using LinearAlgebra, Plots
#+end_src

** Constants
#+begin_src julia
const ħ = 1.0545718e-34
#+end_src

** Types
#+begin_src julia
"""
    GreaterThan(x::T, min::T) where {T<:Real}

Define a type that ensures `x` is greater than `min`

# Examples
```jldoctest
julia> struct Wavefunction
           n::GreaterThan{Int8}

           function Wavefunction(principal::Int8)
               n = GreaterThan(principal, 0)
           end
        end
```
"""
struct GreaterThan{T<:Real}
    x::T
    min::T

    function GreaterThan(x::T, min::T) where {T<:Real}
        if x < min
            throw(DomainError("$x must be >= $min"))
        end
        new{T}(x, min)
    end
end
#+end_src

#+begin_src julia
"""
    Between(x::T, min::T, max::T) where {T<:Real}

Define a type that ensures `x` is between the `min` and `max` values

# Examples
```jldoctest
julia> struct Wavefunction
           n::Int8
           l::Between{Int8}

           function Wavefunction(principal::Int8, azimuthal::Int8)
               n = principal
               l = Between(azimuthal, 0, n - 1)
           end
       end
```
"""
struct Between{T<:Real}
    x::T
    min::T
    max::T

    function Between(x::T, min::T, max::T) where {T<:Real}
        if x < min || x > max
            throw(DomainError("$x must be in [$min, $max]"))
        end
        new{T}(x, min, max)
    end
end
#+end_src

#+begin_src julia
"""
    BetweenPlusMinus(x::T, origin::T) where {T<:Real}

Define a type that ensures `x` is between ±`origin`

# Examples
```jldoctest
julia> struct Wavefunction
           l::Int8
           m_l::BetweenPlusMinus{Int8}

           function Wavefunction(aizmuthal::Int8, magnetic::Int8)
               l = principal
               m_l = BetweenPlusMinus(magnetic, l)
           end
       end
```
"""
struct BetweenPlusMinus{T<:Real}
    x::T
    origin::T

    function BetweenPlusMinus(x::T, origin::T) where {T<:Real}
        if x < -origin || x > origin
            throw(DomainError("$x must be in [-$origin, $origin]"))
        end
        new{T}(x, origin)
    end
end
#+end_src

* Model System
We can set up a spin-orbit coupling Hamiltonian for a model system, where the wavefunction is represented in a basis of the \(\ell\), \(m_{\ell}\), and \(m_s\) quantum numbers for a given \(n\).

#+name: model-H
\begin{equation}
    \Braket{ \Psi_{\ell, m_{\ell}, m_s} | \lambda \hat{L} \cdot \hat{S} | \Psi_{\ell, m_{\ell}, m_s} }
\end{equation}

Where \(\hat{L}\) is the orbital angular momentum operator, \(\hat{S}\) is the spin operator, and \(\lambda\) is the spin-orbit coupling strength, which is dependent on the atomic number of the elements in the solid.

** Wavefunction
Setup the wavefunction as a ~mutable struct~ so we can enact the ladder operators on the wavefunction object later

*** TODO Solve Initialising the wavefunction
If the wavefunction is initialised with src_julia{Ψ = [Wavefunction(n, l, m_l, m_s) for l in azimuthal, m_l in magnetic, m_s in spin]}, the following will fail because it will try to construct an instance where ~m_l~ < ~l~.

#+begin_src julia
"""
    Wavefunction(
        principal::Int,
        azimuth::Int,
        magnetic::Int,
        spin::AbstractFloat,
    )

Define a wavefunction for a given n in a basis of \$l\$, \$m_l\$, and \$m_s\$

# Examples
```jldoctest
julia> ψ = Wavefunction(2, 1, -1, -0.5)
```
"""
mutable struct Wavefunction
    n::GreaterThan{Int}
    l::Between{Int}
    m_l::BetweenPlusMinus{Int}
    m_s::AbstractFloat

    function Wavefunction(
        n::Int,
        l::Int,
        m_l::Int,
        m_s::AbstractFloat,
    )
        if m_s != 0.5 && m_s != -0.5
            throw(ArgumentError("Spin must be either 0.5 or -0.5"))
        end

        principal = GreaterThan(n, 0)
        azimuthal = Between(l, 0, n - 1)
        magnetic = BetweenPlusMinus(m_l, l)
        spin = m_s
        new(principal, azimuthal, magnetic, spin)
    end
end
#+end_src

* Define the Operator
** Uncertainty Principle
The uncertainty principle states that when two observable operators do not commute, they cannot be measured simultaneously, and the more accurately that one is known, the less accurately the other can be known. For angular momentum, this is given by the Robertson-Schrödinger relation

\begin{equation}
    \sigma_{J_x} \sigma_{J_y} \geq \frac{\hbar}{2} | \langle J_z \rangle |
\end{equation}

where \(\sigma_J\) is the standard deviation in the measured values of \(J\). \(J\) can also be replaced by \(L\) or \(S\), and \(x, y, z\) can be rearranged in any order. However it is still possible to measure \(J^2\) and any one component of \(J\). These values are characterised by \(\ell\) and \(m\).

** Derivation
In order to calculate [[model]], we need to apply the operators to the ket and work out the prefactors.

#+name: angular-spin-relation
\begin{equation}
    \begin{split}
        \hat{J}^2 &= \left( \hat{L} + \hat{S} \right)^2 \\
        &= \hat{L}^2 + \hat{S}^2 + 2\hat{L} \cdot \hat{S} \\
        &= \hat{L}^2 + \hat{S}^2 + 2\hat{L}_z\hat{S}_z + \hat{L}_+\hat{S}_- + \hat{L}_-\hat{S}_+ \\
    \end{split}
\end{equation}

However, we can neglect the \(\hat{L}^2 + \hat{S}^2\) terms as they are not included in our Hamiltonian in [[model]]. Now, to define how each operator acts on the ket

\begin{equation}
    \begin{split}
        \hat{L}_z \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \hbar m_{\ell} \Ket{ \psi_{\ell, m_{\ell}, m_s} } \\
        \hat{S}_z \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \hbar m_S \Ket{ \psi_{\ell, m_{\ell}, m_s} }
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        L_+ \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (\ell + m_{\ell} + 1)(l - m_{\ell}) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell} + 1, m_s} } \\
        L_- \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (\ell - m_{\ell} + 1)(l + m_{\ell}) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell} - 1, m_s} }
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        S_+ \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (s + m_s + 1)(s - m_s) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell}, m_s + 1} } \\
        S_- \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (s - m_s + 1)(s + m_s) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell}, m_s - 1} } \\
    \end{split}
\end{equation}

Then, substituting [[angular-spin-relation]] into [[model-H]], and applying \(\lambda (\hat{L} \cdot \hat{S})\) to \(\Ket{ \psi_{\ell, m_{\ell}, m_s} }\):

\begin{equation}
    \implies \lambda (\hat{L} \cdot \hat{S}) \Ket{ \Psi_{\ell, m_{\ell}, m_s} } = \frac{\lambda \hbar}{2}(m_{\ell} \cdot m_s) \Ket{ \psi_{\ell, m_{\ell}, m_s} } + \frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - 3m_{\ell})(s^2 + s - 3m_s) \right]^{\frac{1}{2}} \Ket{ \psi_{\ell, m_{\ell} + 1, m_s - 1} } + \frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - m_{\ell})(s^2 + s - m_s) \right]^{\frac{1}{2}} \Ket{ \psi_{\ell, m_{\ell} - 1, m_s + 1} }
\end{equation}

\begin{equation}
    \implies \Braket{ \Psi_{\ell', m_{\ell}', m_s'} | \lambda (\hat{L} \cdot \hat{S}) | \Psi_{\ell, m_{\ell}, m_s} } = \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_z \hat{S}_z | \psi_{\ell, m_{\ell}, m_s} } + \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_+ \hat{S}_- | \psi_{\ell, m_{\ell} + 1, m_s - 1} } + \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_- \hat{S}_- | \psi_{\ell, m_{\ell} - 1, m_s + 1} }
\end{equation}

where

\begin{equation}
    \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \psi_{\ell, m_{\ell}, m_s} } = \delta_{\ell' \ell} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
\end{equation}

* Setup the Eigenvalue Problem
** Operator(s) on Ket
Define how the Hamiltonian acts on the wavefunction in the ket

#+begin_src julia
@doc raw"""
    L_z_S_z_prefactor(ψ::Wavefunction, λ::Float64)

Calculate the z angular momentum spin operator prefactor

```math
\frac{\lambda \hbar}{2} (m_l \cdot m_s) | \psi_{\ell, m_{\ell}, m_s} \rangle
```
"""
L_z_S_z_prefactor(ψ::Wavefunction, λ::Float64) = ((λ * ħ) / 2) * (ψ.m_l * ψ.m_s)
#+end_src

#+begin_src julia
@doc raw"""
    l_up_s_down_prefactor(ψ::wavefunction, λ::float64)

Calculate the L_+S_- operator prefactor.

```math
\frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - 3m_{\ell})(s^2 + s - 3m_s) \right]^{\frac{1}{2}} | \psi_{\ell, m_{\ell} + 1, m_s - 1} \rangle
```
"""
L_up_S_down_prefactor(ψ::Wavefunction, λ::Float64) =
    (λ * ħ^2) / 2 * ((ψ.l^2 + l - (3 * ψ.m_l)) * (0.5^2 + 0.5 - (3 * ψ.m_s)))^0.5
#+end_src

#+begin_src julia
@doc raw"""
    L_down_S_up_prefactor(ψ::Wavefunction, λ::Float64)

Calculate the L_-S_+ operator prefactor.

```math
\frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - m_{\ell})(s^2 + s - m_s) \right]^{\frac{1}{2}} | \psi_{\ell, m_{\ell} - 1, m_s + 1} \rangle
```
"""
L_down_S_up_prefactor(ψ::Wavefunction, λ::Float64) =
    (ψ.λ * ħ^2) / 2 * ((ψ.l^2 + l - ψ.m_l) * (0.5^2 + 0.5 - ψ.m_s))^0.5
#+end_src

Additionally create \(\Bra{\psi'}\) and enact the operators on \(\Ket{\psi}\). These only need to be defined for \(\hat{L}_+\hat{S}_-\) and \(\hat{L}_-\hat{S}_+\) as \(\hat{L}_z\hat{S}_z\) does not raise or lower the quantum numbers and only serves as a prefactor.

#+begin_src julia
function L_up_S_down_ladder!(ψ::Wavefunction)
    # L_+S_- raises m_l and lowers m_s both by 1
    if ψ.m_l > l - 1 && m_s == 0.5
        ψ.m_l += 1
        ψ.m_s -= 1
        return ψ
    else
        return 0
    end
end
#+end_src

#+begin_src julia
function L_down_S_up_ladder!(ψ::Wavefunction)
    # L_-S_+ lowers m_l and raises m_s both by 1
    if ψ.m_l < -l + 1 && m_s == -0.5
        ψ.m_l -= 1
        ψ.m_s += 1
        return ψ
    else
        return 0
    end
end
#+end_src

** Bra on ket
Set \(\hat{H}_{ij}\) in accordance with \(\Braket{ \psi_{\ell', m_{\ell}', m_s'} | \psi_{\ell, m_{\ell}, m_s} } = \delta_{\ell'\ell} \delta_{m_{\ell}'m_{\ell}} \delta_{m_s'm_s}\)

#+begin_src julia
function ψOψ(ψ_prime::Wavefunction, ψ::Wavefunction, operator::String)
    if operator == "L_z_S_z"
        if ψ_prime.l == ψ.l && ψ_prime.m_l == ψ.m_l && ψ_prime.s == ψ.s
            return L_z_S_z_prefactor(ψ)
        else
            return 0
        end

    elseif operator == "L_up_S_down"
        if ψ_prime.l == ψ.l && ψ_prime.m_l == ψ.m_l + 1 && ψ_prime.s == ψ.s - 1
            return L_up_S_down_prefactor(ψ)
        else
            return 0
        end

    elseif operator == "L_down_S_up"
        if ψ_prime.l == ψ.l && ψ_prime.m_l == ψ.m_l - 1 && ψ_prime.s == ψ.s + 1
            return 0
        else
            return L_down_S_up_prefactor(ψ)
        end
    else
        throw(
            ArgumentError(
                "Operator must be one of 'L_z_S_z', 'L_up_S_down', 'L_down_S_up'",
            ),
        )
    end
end
#+end_src

** Operators as Matrices
The above operators can also be represented as matrices

#+begin_src julia
function construct_operator_matrices(Ψ::Wavefunction, Ψ_prime::Wavefunction)

    # Get the total number of states
    num_states = length(Ψ)

    # Check that the number of states in Ψ and Ψ_prime are the same
    @assert num_states == length(Ψ_prime)

    # Define matrix operators for L_z, S_z, L_up, L_down, S_up, S_down
    L_z_S_z = Array{Float64}(undef, num_states, num_states)
    L_up_S_down = deepcopy(L_z_S_z)
    L_down_S_up = deepcopy(L_z_S_Z)

    # Set the matrix elements of the operators
end
#+end_src

* Solve the Eigenvalue Problem
** Setup the Hamiltonian
Iterate over all quantum numbers to create \(\hat{H}\) for \(n=2\)

#+begin_src julia
λ = [1]
#+end_src

#+begin_src julia
begin
    n = 2
    l = collect(Int8, 0:n-1)
    m_l = collect(Int8, -maximum(l):maximum(l))
    m_s = Float16[-0.5, 0.5]
end
#+end_src

#+begin_src julia
function construct_full_H(
    lambda::Vector{Float64},
    n::Int8,
    azimuthal::Vector{Int8},
    magnetic::Vector{Int8},
    spin::Vector{Float16},
)
    # Setup Ψ as a vector of all possible wavefunctions
    Ψ = [Wavefunction(n, l, m_l, m_s) for l in azimuthal, m_l in magnetic, m_s in spin]

    # Construct Ψ_prime
    Ψ_prime = deepcopy(Ψ)

    # Construct the Hamiltonian matrix
    H = Array{Float64,2}(nothing, length(Ψ_prime), length(Ψ))

    # Construct the Hamiltonian matrix
    for ψ in eachindex(Ψ)
        for ψ_prime in eachindex(Ψ_prime)
            # Calculate prefactor for L_zS_z
            term_1 = ψOψ(Ψ_prime[ψ_prime], Ψ[ψ], "L_z_S_z")

            # L_+S_- ladder
            ψ_2 = deepcopy(Ψ[ψ])
            L_up_S_down_ladder!(ψ_2)
            # L_+S_- prefactor
            term_2 = ψOψ(Ψ_prime[ψ_prime], ψ_2, "L_up_S_down")

            # L_-S_+ ladder
            ψ_3 = deepcopy(ψ)
            L_down_S_up_ladder!(ψ_3)
            # L_-S_+ prefactor
            term_3 = ψOψ(ψ_prime, ψ_3, "L_down_S_up")

            H[ψ_prime, ψ] = sum(λ .* [term_1, term_2, term_3])
        end
    end

    return H
end

H = construct_full_H(m, l, m_l, m_s)
#+end_src

** Diagonalise the Hamiltonian
#+begin_src julia
function diagonalise_H(H::Array{Float64,2})
    # Find the eigenvalues and eigenvectors of the Hamiltonian
    eigen = eigen(H)

    # Get the diagonal matrix of eigenvalues
    D = Diagonal(eigen.values)

    return D

    # Check that the diagonal Hamiltonian is within numerical error of D
    # P = eigen.vectors
    # @assert norm(H - (P * D * inv(P))) < 1e-10

end

H_d = diagonalise_H(H)
#+end_src
