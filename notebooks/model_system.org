#+title: Model System
#+startup: latexpreview inlineimages
#+latex_header: \usepackage{braket}
#+property: header-args:julia :session jl :results silent

* Setup
** Imports
#+begin_src julia
using DrWatson
quickactivate("$(pwd())../")
using LinearAlgebra, Plots
#+end_src

** Constants
#+begin_src julia
const ħ = 1.0545718e-34
#+end_src

* Model System
We can set up a spin-orbit coupling Hamiltonian for a model system, where the wavefunction is represented in a basis of the \(\ell\), \(m_{\ell}\), and \(m_s\) quantum numbers for a given \(n\).

#+name: model-H
\begin{equation}
    \Braket{ \Psi_{\ell, m_{\ell}, m_s} | \lambda \hat{L} \cdot \hat{S} | \Psi_{\ell, m_{\ell}, m_s} }
\end{equation}

Where \(\hat{L}\) is the orbital angular momentum operator, \(\hat{S}\) is the spin operator, and \(\lambda\) is the spin-orbit coupling strength, which is dependent on the atomic number of the elements in the solid.

** TODO Wavefunction
- Setup the Wavefunction to be complex rather than vectors of ints/floats

Setup the wavefunction as a ~mutable struct~ so we can enact the ladder operators on the wavefunction object later

#+begin_src julia
@doc raw"""
    Wavefunction(n::Int64)

Define a wavefunction for a given n in a basis of $l$, $m_l$, and $m_s$

The length of the wavefunction vector is given by
```math
\sum_{n=1}^{n} \sum_{l=0}^{n-1} 2(2l + 1)
```

# Examples
```jldoctest
julia> Ψ = Wavefunction(2)
```

"""
mutable struct Wavefunction
    Ψ::Vector{Tuple{Int64,Int64,Float64}}
    l::Vector{Int64}
    m_l::Vector{Int64}
    m_s::Vector{Float64}

    function Wavefunction(n::Int64)
        # Ensure n is greater than 0
        if n < 0
            throw(ArgumentError("n must be ∈ ℕ₀"))
        end

        # Calculate the total number of combinations
        len_Ψ = sum((2 * l + 1) * 2 for l = 0:n-1)

        # Create a matrix for all possible values of quantum numbers
        Ψ = Vector{Tuple{Int64,Int64,Float64}}(undef, len_Ψ)

        idx = 1
        for l = 0:n-1
            for m_l = -l:l
                for m_s = -0.5:0.5
                    Ψ[idx] = (l, m_l, m_s)
                    idx += 1
                end
            end
        end

        # Save vectors of the quantum numbers
        l = [Ψ[i][1] for i = 1:len_Ψ]
        m_l = [Ψ[i][2] for i = 1:len_Ψ]
        m_s = [Ψ[i][3] for i = 1:len_Ψ]

        new(Ψ, l, m_l, m_s)
    end
end
#+end_src

* Define the Operator
** Uncertainty Principle
The uncertainty principle states that when two observable operators do not commute, they cannot be measured simultaneously, and the more accurately that one is known, the less accurately the other can be known. For angular momentum, this is given by the Robertson-Schrödinger relation

\begin{equation}
    \sigma_{J_x} \sigma_{J_y} \geq \frac{\hbar}{2} | \langle J_z \rangle |
\end{equation}

where \(\sigma_J\) is the standard deviation in the measured values of \(J\). \(J\) can also be replaced by \(L\) or \(S\), and \(x, y, z\) can be rearranged in any order. However it is still possible to measure \(J^2\) and any one component of \(J\). These values are characterised by \(\ell\) and \(m\).

** Derivation
In order to calculate [[model]], we need to apply the operators to the ket and work out the prefactors.

#+name: angular-spin-relation
\begin{equation}
    \begin{split}
        \hat{J}^2 &= \left( \hat{L} + \hat{S} \right)^2 \\
        &= \hat{L}^2 + \hat{S}^2 + 2\hat{L} \cdot \hat{S} \\
        &= \hat{L}^2 + \hat{S}^2 + 2\hat{L}_z\hat{S}_z + \hat{L}_+\hat{S}_- + \hat{L}_-\hat{S}_+ \\
    \end{split}
\end{equation}

However, we can neglect the \(\hat{L}^2 + \hat{S}^2\) terms as they are not included in our Hamiltonian in [[model]]. Now, to define how each operator acts on the ket

\begin{equation}
    \begin{split}
        \hat{L}_z \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \hbar m_{\ell} \Ket{ \psi_{\ell, m_{\ell}, m_s} } \\
        \hat{S}_z \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \hbar m_S \Ket{ \psi_{\ell, m_{\ell}, m_s} }
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        L_+ \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (\ell + m_{\ell} + 1)(l - m_{\ell}) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell} + 1, m_s} } \\
        L_- \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (\ell - m_{\ell} + 1)(l + m_{\ell}) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell} - 1, m_s} }
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        S_+ \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (s + m_s + 1)(s - m_s) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell}, m_s + 1} } \\
        S_- \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (s - m_s + 1)(s + m_s) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell}, m_s - 1} } \\
    \end{split}
\end{equation}

Then, substituting [[angular-spin-relation]] into [[model-H]], and applying \(\lambda (\hat{L} \cdot \hat{S})\) to \(\Ket{ \psi_{\ell, m_{\ell}, m_s} }\):

\begin{equation}
    \implies \lambda (\hat{L} \cdot \hat{S}) \Ket{ \Psi_{\ell, m_{\ell}, m_s} } = \frac{\lambda \hbar}{2}(m_{\ell} \cdot m_s) \Ket{ \psi_{\ell, m_{\ell}, m_s} } + \frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - 3m_{\ell})(s^2 + s - 3m_s) \right]^{\frac{1}{2}} \Ket{ \psi_{\ell, m_{\ell} + 1, m_s - 1} } + \frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - m_{\ell})(s^2 + s - m_s) \right]^{\frac{1}{2}} \Ket{ \psi_{\ell, m_{\ell} - 1, m_s + 1} }
\end{equation}

\begin{equation}
    \implies \Braket{ \Psi_{\ell', m_{\ell}', m_s'} | \lambda (\hat{L} \cdot \hat{S}) | \Psi_{\ell, m_{\ell}, m_s} } = \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_z \hat{S}_z | \psi_{\ell, m_{\ell}, m_s} } + \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_+ \hat{S}_- | \psi_{\ell, m_{\ell} + 1, m_s - 1} } + \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_- \hat{S}_- | \psi_{\ell, m_{\ell} - 1, m_s + 1} }
\end{equation}

where

\begin{equation}
    \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \psi_{\ell, m_{\ell}, m_s} } = \delta_{\ell' \ell} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
\end{equation}

* Setup the Eigenvalue Problem
** Operator(s) on Ket
Define how the Hamiltonian acts on the wavefunction in the ket

#+begin_src julia
@doc raw"""
    Lz_Sz_prefactor(Ψ::Wavefunction, λ::Float64)

Calculate the z angular momentum spin operator prefactor

```math
\frac{\lambda \hbar}{2} (m_l \cdot m_s) | \psi_{\ell, m_{\ell}, m_s} \rangle
```
"""
Lz_Sz_prefactor(Ψ::Wavefunction, λ::Float64) = ((λ * ħ) / 2) .* (Ψ.m_l .* Ψ.m_s)
#+end_src

#+begin_src julia
@doc raw"""
    l_up_s_down_prefactor(ψ::Vector{Wavefunction}, λ::float64)

Calculate the L_+S_- operator prefactor.

```math
\frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - 3m_{\ell})(s^2 + s - 3m_s) \right]^{\frac{1}{2}} | \psi_{\ell, m_{\ell} + 1, m_s - 1} \rangle
```
"""
# L_up_S_down_prefactor(Ψ::Wavefunction, λ::Float64) = [(λ * ħ^2) / 2 * ((ψ.l^2 + l - (3 * ψ.m_l)) * (0.5^2 + 0.5 - (3 * ψ.m_s)))^0.5 for ψ in Ψ]

function L_up_S_down_prefactor(Ψ::Wavefunction, λ::Float64)
    ((λ * ħ^2) / 2) .*
    ((ψ.l .^ 2 .+ ψ_l .- (3 .* ψ.m_l)) .* (m_s .^ 2 .+ m_s .- (3 .* ψ.m_s))) .^ 0.5
end
#+end_src

#+begin_src julia
@doc raw"""
    L_down_S_up_prefactor(ψ::Vector{Wavefunction}, λ::Float64)

Calculate the L_-S_+ operator prefactor.

```math
\frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - m_{\ell})(s^2 + s - m_s) \right]^{\frac{1}{2}} | \psi_{\ell, m_{\ell} - 1, m_s + 1} \rangle
```
"""
function L_down_S_up_prefactor(ψ::Vector{Wavefunction}, λ::Float64)
    return [(ψ.λ * ħ^2) / 2 * ((ψ.l^2 + l - ψ.m_l) * (0.5^2 + 0.5 - ψ.m_s))^0.5 for ψ in Ψ]
end
#+end_src

** Bra on ket
Additionally create \(\Bra{\psi'}\) and enact the operators on \(\Ket{\psi}\). These only need to be defined for \(\hat{L}_+\hat{S}_-\) and \(\hat{L}_-\hat{S}_+\) as \(\hat{L}_z\hat{S}_z\) does not raise or lower the quantum numbers and only serves as a prefactor.

#+begin_src julia
@doc raw"""
    L_up_S_down_mask(Ψ::Vector{Wavefunction}, Ψ_prime::Vector{Wavefunction})

Use logical indexing to apply prefactors based on quantum number rules

```math
\langle \Psi_{\ell', m_{\ell}', m_s'} | L_+S_- | \Psi_{\ell, m_{\ell}+1, m_s-1} = \delta_{l' l} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
"""
function L_up_S_down_mask(Ψ::Vector{Wavefunction}, Ψ_prime::Vector{Wavefunction})
    return [
        (ψ_prime.l == ψ.l && ψ_prime.m_l == ψ.m_l + 1 && ψ_prime.m_s == ψ.m_s - 1) for
        ψ_prime in Ψ, ψ in Ψ
    ]
end
#+end_src

#+begin_src julia
@doc raw"""
    L_up_S_down_mask(Ψ::Vector{Wavefunction}, Ψ_prime::Vector{Wavefunction})

Use logical indexing to apply prefactors based on quantum number rules

```math
\langle \Psi_{\ell', m_{\ell}', m_s'} | L_+S_- | \Psi_{\ell, m_{\ell}-1, m_s+1} = \delta_{l' l} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
"""
function L_down_S_up_mask(Ψ::Vector{Wavefunction}, Ψ_prime::Vector{Wavefunction})
    return [
        (ψ_prime.l == ψ.l && ψ_prime.m_l == ψ.m_l - 1 && ψ_prime.m_s == ψ.m_s + 1) for
        ψ_prime in Ψ, ψ in Ψ
    ]
end
#+end_src

* Solve the Eigenvalue Problem
** Setup the Hamiltonian
Iterate over all quantum numbers to create \(\hat{H}\) for \(n=2\)

#+begin_src julia
λ = [1]
#+end_src

Setup rules for the quantum numbers

#+begin_src julia
#+end_src

#+begin_src julia
function construct_full_H(
    lambda::Vector{Float64},
    n::Int8,
    azimuthal::Vector{Int8},
    magnetic::Vector{Int8},
    spin::Vector{Float16},
)
    # Setup Ψ as a vector of all possible wavefunctions
    Ψ =

    # Construct Ψ_prime
    Ψ_prime = deepcopy(Ψ)

    # Construct the Hamiltonian matrix
    H = Array{Float64,2}(nothing, length(Ψ_prime), length(Ψ))

    # Construct the Hamiltonian matrix
    for ψ in eachindex(Ψ)
        for ψ_prime in eachindex(Ψ_prime)
            # Calculate prefactor for L_zS_z
            term_1 = ψOψ(Ψ_prime[ψ_prime], Ψ[ψ], "L_z_S_z")

            # L_+S_- ladder
            ψ_2 = deepcopy(Ψ[ψ])
            L_up_S_down_ladder!(ψ_2)
            # L_+S_- prefactor
            term_2 = ψOψ(Ψ_prime[ψ_prime], ψ_2, "L_up_S_down")

            # L_-S_+ ladder
            ψ_3 = deepcopy(ψ)
            L_down_S_up_ladder!(ψ_3)
            # L_-S_+ prefactor
            term_3 = ψOψ(ψ_prime, ψ_3, "L_down_S_up")

            H[ψ_prime, ψ] = sum(λ .* [term_1, term_2, term_3])
        end
    end

    return H
end

H = construct_full_H(m, l, m_l, m_s)
#+end_src

** Diagonalise the Hamiltonian
#+begin_src julia
function diagonalise_H(H::Array{Float64,2})
    # Find the eigenvalues and eigenvectors of the Hamiltonian
    eigen = eigen(H)

    # Get the diagonal matrix of eigenvalues
    D = Diagonal(eigen.values)

    return D

    # Check that the diagonal Hamiltonian is within numerical error of D
    # P = eigen.vectors
    # @assert norm(H - (P * D * inv(P))) < 1e-10

end

H_d = diagonalise_H(H)
#+end_src
