### A Pluto.jl notebook ###
# Generated by ox-pluto for Pluto v0.18+
# Created 2024-09-07 Sat 13:52

using InteractiveUtils

# ╔═╡ b51e94b3-338f-4634-86e5-2198798c0e4e
using Org

# ╔═╡ b4b7c648-1aca-4b11-968b-5bf158f397ee
org"""
#+title: Model System
#+author: Dylan Morgan
#+startup: latexpreview inlineimages
#+latex_header: \usepackage{braket}
#+auto_tangle: t
#+property: header-args:julia :session jl :results silent
#+property: header-args :tangle ../scripts/DeltaSCFSOC.jl

## Module :noexport:
Start a module here for tangling with the jl file. We will prevent it from running from here as it will error without an ~end~ clause. Also do not export it

"""

# ╔═╡ 7bf3c9f2-b283-46f0-8e30-692f2bf16bd7
module DeltaSCFSOC

# ╔═╡ 92b42987-c127-4b1f-b059-b23e8905727a
org"""
## Imports
"""

# ╔═╡ 5b087d57-6354-4343-ad06-8446902ebc76
using DrWatson
quickactivate("$(pwd())../")
using LinearAlgebra, Plots

# ╔═╡ 37b7ea42-f338-4119-b655-76fbd2c42906
org"""
## Constants
"""

# ╔═╡ 77ff3093-3f4f-4634-b2a8-29aac9c31f5c
const ħ = 1.0545718e-34

# ╔═╡ 08b54823-c344-4f87-bbe2-3aed20c88b8d
org"""
We can set up a spin-orbit coupling Hamiltonian for a model system, where the wavefunction is represented in a basis of the $$\ell$$, $$m_{\ell}$$, and $$m_s$$ quantum numbers for a given $$n$$.

#+name: model-H
\begin{equation}
    \Braket{ \Psi_{\ell, m_{\ell}, m_s} | \lambda \hat{L} \cdot \hat{S} | \Psi_{\ell, m_{\ell}, m_s} }
\end{equation}

Where $$\hat{L}$$ is the orbital angular momentum operator, $$\hat{S}$$ is the spin operator, and $$\lambda$$ is the spin-orbit coupling strength, which is dependent on the atomic number of the elements in the solid.

## Wavefunction
Setup the wavefunction as a ~mutable struct~ using the quantum numbers as a basis. This will create a vector where each element is a state defined by the quantum numbers

"""

# ╔═╡ 7749cf04-4b24-4bc6-b510-4e6d81ccf6a2
@doc raw"""
    Wavefunction(n::Int64)

Define a wavefunction for a given n in a basis of $l$, $m_l$, and $m_s$

The length of the wavefunction vector is given by
```math
\sum_{n=1}^{n} \sum_{l=0}^{n-1} 2(2l + 1)
```

# Examples
```jldoctest
julia> Ψ = Wavefunction(2)
```
"""
mutable struct Wavefunction
    Ψ::Vector{Tuple{Int64,Complex{Int64},ComplexF64}}
    l::Vector{Int16}
    m_l::Vector{Complex{Int64}}
    m_s::Vector{ComplexF64}

    function Wavefunction(n::Int64)
        # Ensure n is greater than 0
        if n < 0
            throw(ArgumentError("n must be ∈ ℕ₀"))
        end

        # Calculate the total number of combinations
        len_Ψ = sum((2 * l + 1) * 2 for l = 0:n-1)

        # Create a matrix for all possible values of quantum numbers
        Ψ = Vector{Tuple{Int64,Complex{Int64},ComplexF64}}(undef, len_Ψ)

        idx = 1
        for l = 0:n-1
            for m_l = -l:l
                for m_s = -0.5:0.5
                    Ψ[idx] = (l, m_l, m_s)
                    idx += 1
                end
            end
        end

        # Save vectors of the quantum numbers
        l = [Ψ[i][1] for i = 1:len_Ψ]
        m_l = [Ψ[i][2] for i = 1:len_Ψ]
        m_s = [Ψ[i][3] for i = 1:len_Ψ]

        new(Ψ, l, m_l, m_s)
    end
end

# ╔═╡ e7d82dd0-767c-46f4-8c16-c25b83d473b1
org"""
Now, initialise the wavefunction when $$n=2$$

"""

# ╔═╡ b02fa56f-bfd1-4e91-b12f-025ec430850f
Ψ = Wavefunction(2)

# ╔═╡ 1e9022e2-b752-444b-b1d1-c16277729a87
org"""
#+results: 
: Wavefunction(Tuple{Int64, Complex{Int64}, ComplexF64}[(0, 0 + 0im, -0.5 + 0.0im), (0, 0 + 0im, 0.5 + 0.0im), (1, -1 + 0im, -0.5 + 0.0im), (1, -1 + 0im, 0.5 + 0.0im), (1, 0 + 0im, -0.5 + 0.0im), (1, 0 + 0im, 0.5 + 0.0im), (1, 1 + 0im, -0.5 + 0.0im), (1, 1 + 0im, 0.5 + 0.0im)], Int16[0, 0, 1, 1, 1, 1, 1, 1], Complex{Int64}[0 + 0im, 0 + 0im, -1 + 0im, -1 + 0im, 0 + 0im, 0 + 0im, 1 + 0im, 1 + 0im], ComplexF64[-0.5 + 0.0im, 0.5 + 0.0im, -0.5 + 0.0im, 0.5 + 0.0im, -0.5 + 0.0im, 0.5 + 0.0im, -0.5 + 0.0im, 0.5 + 0.0im])


## Uncertainty Principle
The uncertainty principle states that when two observable operators do not commute, they cannot be measured simultaneously, and the more accurately that one is known, the less accurately the other can be known. For angular momentum, this is given by the Robertson-Schrödinger relation

\begin{equation}
    \sigma_{J_x} \sigma_{J_y} \geq \frac{\hbar}{2} | \langle J_z \rangle |
\end{equation}

where $$\sigma_J$$ is the standard deviation in the measured values of $$J$$. $$J$$ can also be replaced by $$L$$ or $$S$$, and $$x, y, z$$ can be rearranged in any order. However it is still possible to measure $$J^2$$ and any one component of $$J$$. These values are characterised by $$\ell$$ and $$m$$.

## Derivation
In order to calculate [[model]], we need to apply the operators to the ket and work out the prefactors.

#+name: angular-spin-relation
\begin{equation}
    \begin{split}
        \hat{J}^2 &= \left( \hat{L} + \hat{S} \right)^2 \\
        &= \hat{L}^2 + \hat{S}^2 + 2\hat{L} \cdot \hat{S} \\
        &= \hat{L}^2 + \hat{S}^2 + 2\hat{L}_z\hat{S}_z + \hat{L}_+\hat{S}_- + \hat{L}_-\hat{S}_+ \\
    \end{split}
\end{equation}

However, we can neglect the $$\hat{L}^2 + \hat{S}^2$$ terms as they are not included in our Hamiltonian in [[model]]. Now, to define how each operator acts on the ket

\begin{equation}
    \begin{split}
        \hat{L}_z \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \hbar m_{\ell} \Ket{ \psi_{\ell, m_{\ell}, m_s} } \\
        \hat{S}_z \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \hbar m_S \Ket{ \psi_{\ell, m_{\ell}, m_s} }
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        L_+ \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (\ell + m_{\ell} + 1)(l - m_{\ell}) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell} + 1, m_s} } \\
        L_- \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (\ell - m_{\ell} + 1)(l + m_{\ell}) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell} - 1, m_s} }
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        S_+ \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (s + m_s + 1)(s - m_s) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell}, m_s + 1} } \\
        S_- \Ket{ \psi_{\ell, m_{\ell}, m_s} } &= \left[ (s - m_s + 1)(s + m_s) \right]^{\frac{1}{2}} \hbar \Ket{ \psi_{\ell, m_{\ell}, m_s - 1} } \\
    \end{split}
\end{equation}

Then, substituting [[angular-spin-relation]] into [[model-H]], and applying $$\lambda (\hat{L} \cdot \hat{S})$$ to $$\Ket{ \psi_{\ell, m_{\ell}, m_s} }$$:

\begin{equation}
    \implies \lambda (\hat{L} \cdot \hat{S}) \Ket{ \Psi_{\ell, m_{\ell}, m_s} } = \frac{\lambda \hbar}{2}(m_{\ell} \cdot m_s) \Ket{ \psi_{\ell, m_{\ell}, m_s} } + \frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - 3m_{\ell})(s^2 + s - 3m_s) \right]^{\frac{1}{2}} \Ket{ \psi_{\ell, m_{\ell} + 1, m_s - 1} } + \frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - m_{\ell})(s^2 + s - m_s) \right]^{\frac{1}{2}} \Ket{ \psi_{\ell, m_{\ell} - 1, m_s + 1} }
\end{equation}

\begin{equation}
    \implies \Braket{ \Psi_{\ell', m_{\ell}', m_s'} | \lambda (\hat{L} \cdot \hat{S}) | \Psi_{\ell, m_{\ell}, m_s} } = \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_z \hat{S}_z | \psi_{\ell, m_{\ell}, m_s} } + \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_+ \hat{S}_- | \psi_{\ell, m_{\ell} + 1, m_s - 1} } + \lambda \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \hat{L}_- \hat{S}_- | \psi_{\ell, m_{\ell} - 1, m_s + 1} }
\end{equation}

where

\begin{equation}
    \Braket{ \psi_{\ell', m_{\ell}', m_s'} | \psi_{\ell, m_{\ell}, m_s} } = \delta_{\ell' \ell} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
\end{equation}

## Operator(s) on Ket
Define how the Hamiltonian acts on the wavefunction in the ket

"""

# ╔═╡ 0a353a26-9fee-4d30-9594-f707c715405b
@doc raw"""
    Lz_Sz_prefactor(Ψ::Wavefunction, λ::Float64)::Vector{ComplexF64}

Calculate the z angular momentum spin operator prefactor

```math
\frac{\lambda \hbar}{2} (m_l \cdot m_s) | \psi_{\ell, m_{\ell}, m_s} \rangle
```
"""
function Lz_Sz_prefactor(Ψ::Wavefunction, λ::Float64)::Vector{ComplexF64}
    ((λ * ħ) / 2) .* (Ψ.m_l .* Ψ.m_s)
end

# ╔═╡ dd52d8e1-884c-4912-b8c9-ab42739d0f3f
@doc raw"""
    l_up_s_down_prefactor(ψ::Wavefunction, λ::float64)::Vector{ComplexF64}

Calculate the L_+S_- operator prefactor.

```math
\frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - 3m_{\ell})(s^2 + s - 3m_s) \right]^{\frac{1}{2}} | \psi_{\ell, m_{\ell} + 1, m_s - 1} \rangle
```
"""
function L_up_S_down_prefactor(Ψ::Wavefunction, λ::Float64)::Vector{ComplexF64}
    ((λ * ħ^2) / 2) .*
    ((Ψ.l .^ 2 .+ Ψ.l .- (3 .* Ψ.m_l)) .* (Ψ.m_s .^ 2 .+ Ψ.m_s .- (3 .* Ψ.m_s))) .^ 0.5
end

# ╔═╡ 8e885a2a-54b7-4b51-b34a-ce48ba821534
@doc raw"""
    L_down_S_up_prefactor(Ψ::Wavefunction, λ::Float64)::Vector{ComplexF64}

Calculate the L_-S_+ operator prefactor.

```math
\frac{\lambda \hbar^2}{2} \left[ (\ell^2 + \ell - m_{\ell})(s^2 + s - m_s) \right]^{\frac{1}{2}} | \psi_{\ell, m_{\ell} - 1, m_s + 1} \rangle
```
"""
function L_down_S_up_prefactor(Ψ::Wavefunction, λ::Float64)::Vector{ComplexF64}
    ((λ * ħ^2) / 2) .* ((Ψ.l .^ 2 .+ Ψ.l .- Ψ.m_l) .* (Ψ.m_s .^ 2 .+ Ψ.m_s .- Ψ.m_s)) .^ 0.5
end

# ╔═╡ 1059bbea-dab3-499c-ad02-1d16504d91e9
org"""
## Bra on ket
Additionally create $$\Bra{\psi'}$$ and enact the operators on $$\Ket{\psi}$$ to calculate the inner product

"""

# ╔═╡ c7fa648c-f10d-4aeb-9613-cd2badf2b0d9
@doc raw"""
    Lz_Sz_kron(Ψ::Wavefunction)::BitMatrix

Use logical indexing to apply prefactors based on kroenecker delta for the Lz_Sz operator.

```math
\langle \Psi_{\ell', m_{\ell}', m_s'} | L_zS_z | \Psi_{\ell, m_{\ell}, m_s} = \delta_{l' l} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
"""
function Lz_Sz_kron(Ψ::Wavefunction)::BitMatrix
    Ψ.l .== Ψ.l' .&& Ψ.m_l .== Ψ.m_l' .&& Ψ.m_s .== Ψ.m_s'
end

# ╔═╡ 11909189-e837-49e0-b8e3-3d679a919bce
@doc raw"""
    L_up_S_down_kron(Ψ::Wavefunction)::BitMatrix

Use logical indexing to apply prefactors based on kroenecker delta for the L+_S- operator.

```math
\langle \Psi_{\ell', m_{\ell}', m_s'} | L_+S_- | \Psi_{\ell, m_{\ell}+1, m_s-1} = \delta_{l' l} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
"""
function L_up_S_down_kron(Ψ::Wavefunction)::BitMatrix
    Ψ.l .== Ψ.l' .&& Ψ.m_l .== Ψ.m_l' .+ 1 .&& Ψ.m_s .== Ψ.m_s' .- 1
end

# ╔═╡ 752f17aa-d5ff-49c4-b5af-1be6fdffb945
@doc raw"""
    L_up_S_down_kron(Ψ::Wavefunction)::BitMatrix

Use logical indexing to apply prefactors based on kroenecker delta for the L-_S+ operator.

```math
\langle \Psi_{\ell', m_{\ell}', m_s'} | L_+S_- | \Psi_{\ell, m_{\ell}-1, m_s+1} = \delta_{l' l} \delta_{m_{\ell}' m_{\ell}} \delta_{m_s' m_s}
"""
function L_down_S_up_kron(Ψ::Wavefunction)::BitMatrix
    Ψ.l .== Ψ.l' .&& Ψ.m_l .== Ψ.m_l' .- 1 .&& Ψ.m_s .== Ψ.m_s' .+ 1
end

# ╔═╡ 71469543-d06e-4872-911f-27dee0deccfb
org"""
## Setup the Hamiltonian
Iterate over all quantum numbers to create $$\hat{H}$$ for $$n=2$$

"""

# ╔═╡ a1a1bf27-7d38-4948-a5ea-948d1aaad156
function construct_full_H(n::Int, λ::Float64)
    # Setup Ψ as a vector of all possible wavefunctions
    Ψ = Wavefunction(n)

    # Construct the Hamiltonian matrix
    H = Matrix{ComplexF64}(undef, length(Ψ.Ψ), length(Ψ.Ψ))

    # Compute the Hamiltonian matrix elements based on the prefactors and kroenecker deltas
    t1 = Lz_Sz_prefactor(Ψ, λ) .* Lz_Sz_kron(Ψ)
    t2 = L_up_S_down_prefactor(Ψ, λ) .* L_up_S_down_kron(Ψ)
    t3 = L_down_S_up_prefactor(Ψ, λ) .* L_down_S_up_kron(Ψ)

    # Assign the array elements
    H .= t1 .+ t2 .+ t3

    return H
end

# ╔═╡ a9eb9285-98f0-44a0-bf51-0606a431217d
H = construct_full_H(2, 1.0)
# println(H)
# return

# ╔═╡ 84bca301-8f02-432f-91aa-5e79be39b8aa
org"""
## Diagonalise the Hamiltonian
"""

# ╔═╡ 97a6edd7-b739-4e2c-97aa-89738fa81b6e
function diagonalise_H(H::Array{Float64,2})
    # Find the eigenvalues and eigenvectors of the Hamiltonian
    eigen = eigen(H)

    # Get the diagonal matrix of eigenvalues
    D = Diagonal(eigen.values)

    return D

    # Check that the diagonal Hamiltonian is within numerical error of D
    # P = eigen.vectors
    # @assert norm(H - (P * D * inv(P))) < 1e-10

end

# ╔═╡ 6b91bbad-6798-4f92-9deb-0afa607b9348
H_d = diagonalise_H(H)

# ╔═╡ ce50c1cd-3d83-44bd-aa91-0f218da1ab87
org"""
Calculate and diagonalise the Hamilton whilst varying $$\lambda$$

"""

# ╔═╡ 8f43c3e9-1a90-40e4-85bc-50ccae8f4411
function main(n::Int, Λ::Vector{Float64})
    for λ in Λ
        H = construct_full_H(λ, n)
        H_d = diagonlise_H(H)
    end
end

main(2, )

# ╔═╡ 615187e4-ede1-47b9-a178-fbc6c82ad673
org"""
Plot the eigenvalues for various values of \lambda

"""

# ╔═╡ cb19204d-9c2d-4138-ac76-47de3ad4bb86
function plot()

# ╔═╡ fc4a59a9-98b6-491f-9078-0159de2f6979
org"""
End the module that we started to define in [[setup]]

"""

# ╔═╡ a15f762c-cd04-4413-b1a1-1e4435a9c5ef
end  # module

# ╔═╡ Cell order:
# ╟─b51e94b3-338f-4634-86e5-2198798c0e4e
# ╟─b4b7c648-1aca-4b11-968b-5bf158f397ee
# ╠═7bf3c9f2-b283-46f0-8e30-692f2bf16bd7
# ╟─92b42987-c127-4b1f-b059-b23e8905727a
# ╠═5b087d57-6354-4343-ad06-8446902ebc76
# ╟─37b7ea42-f338-4119-b655-76fbd2c42906
# ╠═77ff3093-3f4f-4634-b2a8-29aac9c31f5c
# ╟─08b54823-c344-4f87-bbe2-3aed20c88b8d
# ╠═7749cf04-4b24-4bc6-b510-4e6d81ccf6a2
# ╟─e7d82dd0-767c-46f4-8c16-c25b83d473b1
# ╠═b02fa56f-bfd1-4e91-b12f-025ec430850f
# ╟─1e9022e2-b752-444b-b1d1-c16277729a87
# ╠═0a353a26-9fee-4d30-9594-f707c715405b
# ╠═dd52d8e1-884c-4912-b8c9-ab42739d0f3f
# ╠═8e885a2a-54b7-4b51-b34a-ce48ba821534
# ╟─1059bbea-dab3-499c-ad02-1d16504d91e9
# ╠═c7fa648c-f10d-4aeb-9613-cd2badf2b0d9
# ╠═11909189-e837-49e0-b8e3-3d679a919bce
# ╠═752f17aa-d5ff-49c4-b5af-1be6fdffb945
# ╟─71469543-d06e-4872-911f-27dee0deccfb
# ╠═a1a1bf27-7d38-4948-a5ea-948d1aaad156
# ╠═a9eb9285-98f0-44a0-bf51-0606a431217d
# ╟─84bca301-8f02-432f-91aa-5e79be39b8aa
# ╠═97a6edd7-b739-4e2c-97aa-89738fa81b6e
# ╠═6b91bbad-6798-4f92-9deb-0afa607b9348
# ╟─ce50c1cd-3d83-44bd-aa91-0f218da1ab87
# ╠═8f43c3e9-1a90-40e4-85bc-50ccae8f4411
# ╟─615187e4-ede1-47b9-a178-fbc6c82ad673
# ╠═cb19204d-9c2d-4138-ac76-47de3ad4bb86
# ╟─fc4a59a9-98b6-491f-9078-0159de2f6979
# ╠═a15f762c-cd04-4413-b1a1-1e4435a9c5ef
